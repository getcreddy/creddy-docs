# Creddy Documentation

Creddy is an open source, self-hosted credential management system for AI agents. It provides ephemeral, scoped credentials that automatically expire.


---
## authentication.mdx

# Client Authentication

Creddy uses public-key cryptography for client authentication. No shared secrets are stored after initial enrollment.

## How It Works

1. **Client generates a keypair** â€” Ed25519 keys are generated locally
2. **Client requests enrollment** â€” Sends public key to server
3. **Admin approves** â€” Via CLI, Slack, or other integration
4. **Client is activated** â€” All requests are now signed with the private key

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚  1. Generate keypair      â”‚             â”‚
â”‚             â”‚  2. Send public key â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚                           â”‚   Server    â”‚
â”‚             â”‚  (pending approval)       â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ 3. Notify admin
                                                 â–¼
                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                          â”‚   Admin     â”‚
                                          â”‚  (CLI/Slack)â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â”‚
                                                 â”‚ 4. Approve
                                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚  5. Enrollment complete   â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â”‚             â”‚                           â”‚             â”‚
â”‚             â”‚  6. Signed requests â”€â”€â”€â”€â–¶ â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Enrolling a Client

### Step 1: Enroll the Client

```bash
$ creddy enroll https://creddy.example.com --name my-laptop

Generating keypair... done
Registering with server... done

Waiting for approval...
  Name:        my-laptop
  Fingerprint: SHA256:xK3E8f...
  Expires:     4:58 remaining

Ask an admin to approve, or run:
  creddy admin approve enr_abc123

â£¾ Waiting for approval... (4:32 remaining)

âœ“ Approved by admin@example.com
âœ“ Client registered: cli_xyz789
âœ“ Credentials saved to ~/.config/creddy/

Ready. Try: creddy backends
```

The client generates an Ed25519 keypair and sends the public key to the server. The enrollment request is held in a "pending" state until an admin approves it.

### Step 2: Admin Approval

Admins can approve enrollments via CLI:

```bash
# List pending enrollments
$ creddy admin enrollments

ID            NAME        USER    HOST              IP              EXPIRES
enr_abc123    my-laptop   marc    marcbook.local    192.168.1.50    4:32

# Approve
$ creddy admin approve enr_abc123
âœ“ Approved my-laptop (cli_xyz789)

# Or deny
$ creddy admin deny enr_abc123 --reason "unknown device"
âœ— Denied my-laptop
```

Or via Slack (if configured):

```
ðŸ”‘ New Client Enrollment Request

Name:        my-laptop
User:        marc  
Host:        marcbook.local
IP:          192.168.1.50
Fingerprint: SHA256:xK3E8f...

â±ï¸ Expires in 5 minutes

[âœ“ Approve]  [âœ— Deny]
```

## Request Signing

After enrollment, all API requests are signed with the client's private key:

```
POST /api/v1/credentials HTTP/1.1
Host: creddy.example.com
X-Creddy-Client: cli_xyz789
X-Creddy-Timestamp: 1708531200
X-Creddy-Signature: base64(ed25519_sign(client_id + timestamp + method + path + body_hash))
Content-Type: application/json

{"backend": "github", "ttl": "1h"}
```

The server verifies:
1. Client ID exists and is active
2. Timestamp is within 5 minutes of server time
3. Signature is valid for the request

## Client Roles

Clients can have different roles:

| Role | Permissions |
|------|-------------|
| `operator` | Request credentials, list backends |
| `admin` | All operator permissions + manage enrollments, configure backends |

Assign a role when approving:

```bash
$ creddy admin approve enr_abc123 --role admin
```

Default role is `operator`.

## Stored Credentials

Client credentials are stored in `~/.config/creddy/`:

```
~/.config/creddy/
â”œâ”€â”€ config.yaml      # Server URL, client ID
â”œâ”€â”€ client.key       # Ed25519 private key (mode 0600)
â””â”€â”€ client_id        # Client identifier
```

The private key never leaves the client machine.

## Key Rotation

To rotate a client's keypair:

```bash
$ creddy rotate-key

Generating new keypair... done
Requesting key rotation... done

New fingerprint: SHA256:yL4F9g...
Old key will remain valid for 24 hours.

âœ“ Key rotation complete
```

The server accepts both old and new keys during the grace period.

## Revoking Clients

Admins can revoke a client's access:

```bash
$ creddy admin clients

ID            NAME        ROLE      LAST SEEN           STATUS
cli_xyz789    my-laptop   operator  2024-01-15 15:30    active
cli_abc123    ci-runner   operator  2024-01-15 14:00    active

$ creddy admin revoke cli_xyz789
âœ“ Revoked my-laptop
```

Revoked clients cannot make any API requests.

## Bootstrap Admin

On first server start, you need at least one admin. Options:

### Option 1: Config File

Add your public key fingerprint to the server config:

```yaml
# creddy-server.yaml
admins:
  - fingerprint: "SHA256:xK3E8f..."
```

### Option 2: Bootstrap Token

Server generates a one-time admin token on first start:

```bash
$ creddy server
No admin configured. Bootstrap token (single use):
  ctk_XXXXXXXXXXXXX

Run on your machine:
  creddy init --admin-token ctk_XXXXXXXXXXXXX
```

## Auto-Approve Rules

For CI/CD environments, you can configure auto-approve rules:

```yaml
# creddy-server.yaml
enrollment:
  auto_approve:
    - cidr: 10.0.0.0/8           # Internal network
    - hostname_pattern: "ci-*"   # CI runners
  
  # Enrollments expire after this duration
  pending_ttl: 5m
```

Auto-approved clients get the `operator` role by default.

---
## comparisons.mdx

# Comparisons

Creddy often gets compared to other secrets management tools. Here's how it differs.

## The Short Version

Creddy is **not** a general-purpose secrets manager. It's a narrow, focused tool for one thing: **giving AI agents isolated, ephemeral credentials**.

If you're managing production infrastructure secrets, customer data encryption keys, or enterprise compliance requirements â€” use Vault, AWS Secrets Manager, or similar tools. They're excellent at what they do.

Creddy is for a different problem: you have AI agents that need API access, and you don't want to hand them your personal tokens.

## Creddy vs HashiCorp Vault

[Vault](https://www.vaultproject.io/) is an enterprise-grade secrets management platform.

| | Vault | Creddy |
|---|---|---|
| **Primary use case** | Production infrastructure secrets | AI agent credentials |
| **Complexity** | High (requires ops expertise) | Low (single binary) |
| **Target users** | Platform/DevOps teams | Individual developers, AI agents |
| **Secrets storage** | Yes, stores all secrets | No, connects to existing APIs |
| **Dynamic secrets** | Many backends (databases, cloud, etc.) | Focused backends (GitHub, Anthropic, etc.) |
| **Compliance** | SOC2, HIPAA, etc. | Not designed for compliance |
| **Deployment** | Cluster, HA, unsealing | Single binary, SQLite |

**When to use Vault:** Production secrets, database credentials, PKI, enterprise requirements.

**When to use Creddy:** Giving Claude Code a GitHub token that expires in 10 minutes.

They solve different problems. Many teams will use both.

## Creddy vs Cloud Secrets Managers

AWS Secrets Manager, GCP Secret Manager, Azure Key Vault â€” these are cloud-native secrets storage.

| | Cloud Secrets Managers | Creddy |
|---|---|---|
| **Model** | Store and retrieve secrets | Generate ephemeral credentials |
| **Vendor** | Cloud provider lock-in | Self-hosted, provider agnostic |
| **Agent identity** | Not a focus | Core feature |
| **Credential scoping** | Manual, per-secret | Automatic, per-agent |
| **Cost** | Per-secret, per-request pricing | Free |

**When to use cloud secrets managers:** Production apps on that cloud, team secret sharing.

**When to use Creddy:** You want agents to have their own scoped identities, not access to a shared secret store.

## Creddy vs Doppler

[Doppler](https://www.doppler.com/) is a secrets management platform for development teams.

| | Doppler | Creddy |
|---|---|---|
| **Focus** | Team secrets sync, env management | Agent credential isolation |
| **Model** | Centralized secrets store | Ephemeral credential broker |
| **Pricing** | Free tier, then paid | Free forever (Apache 2.0) |
| **Hosting** | SaaS | Self-hosted only |
| **Agent identity** | Not a focus | Core feature |

**When to use Doppler:** Syncing environment variables across your team and CI/CD.

**When to use Creddy:** Giving each AI agent its own isolated credentials with automatic expiry.

*Note: Creddy can actually issue Doppler service tokens as one of its backends â€” they complement each other.*

## Creddy vs Environment Variables / .env Files

The simplest approach: put tokens in `.env` and let agents use them.

| | .env files | Creddy |
|---|---|---|
| **Setup** | Instant | Minutes |
| **Agent isolation** | âŒ All agents share credentials | âœ… Each agent gets unique credentials |
| **Credential expiry** | âŒ Tokens live forever | âœ… Automatic TTL |
| **Audit trail** | âŒ No visibility | âœ… Full logging |
| **Blast radius** | ðŸ”´ Compromised token = full access | ðŸŸ¢ Compromised token = limited scope, auto-expires |

**When to use .env:** Quick experiments, trusted environments, single-agent setups.

**When to use Creddy:** Multiple agents, any concern about credential exposure, need for auditability.

## What Creddy Is Not

To be clear about Creddy's scope:

- âŒ **Not a secrets store** â€” doesn't store your master credentials (you configure backends separately)
- âŒ **Not for production data** â€” don't use it for customer encryption keys or database passwords
- âŒ **Not enterprise software** â€” no HA clustering, no compliance certifications
- âŒ **Not a Vault replacement** â€” if you need Vault, you need Vault

## What Creddy Is

- âœ… **Agent-native** â€” built specifically for AI agent workflows
- âœ… **Ephemeral by default** â€” credentials expire automatically
- âœ… **Scoped access** â€” agents only get what they need
- âœ… **Simple** â€” single binary, runs anywhere
- âœ… **Free** â€” Apache 2.0, no limits

---

Still not sure which tool to use? [Open an issue](https://github.com/getcreddy/creddy/issues) and describe your use case â€” we're happy to help.

---
## concepts.mdx

# Concepts

Understanding Creddy's core concepts.

## Credentials

A **credential** is a short-lived token that grants access to an external service. Credentials are:

- **Ephemeral** â€” They expire automatically
- **Scoped** â€” They grant only specific permissions
- **Signed** â€” They're cryptographically signed JWTs
- **Auditable** â€” Every issuance is logged

### Anatomy of a Credential

```json
{
  "token": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
  "expires_at": "2024-01-15T16:00:00Z",
  "backend": "github",
  "scopes": ["repo:read", "issues:write"],
  "metadata": {
    "agent_id": "my-agent",
    "task": "update-readme"
  }
}
```

## Backends

A **backend** represents an external service that Creddy can issue credentials for. Backends are configured with the long-lived credentials that Creddy uses to generate short-lived tokens.

### Supported Backend Types

| Type | Description |
|------|-------------|
| `github` | GitHub personal access tokens or app tokens |
| `aws` | AWS IAM credentials (STS temporary credentials) |
| `generic` | Generic secret injection |

### Backend Configuration

```yaml
backends:
  my-github:
    type: github
    token: ghp_xxxxxxxxxxxx
    default_ttl: 1h
    max_ttl: 24h
    allowed_scopes:
      - repo:read
      - repo:write
      - issues:*
```

## Scopes

**Scopes** define what a credential can do. They're backend-specific and follow the principle of least privilege.

### Scope Patterns

- `repo:read` â€” Exact match
- `repo:*` â€” Wildcard (all repo permissions)
- `*` â€” All scopes (use carefully)

### Requesting Scopes

When requesting a credential, specify only the scopes you need:

```json
{
  "backend": "github",
  "scopes": ["repo:read", "issues:write"]
}
```

If no scopes are specified, the backend's default scopes are used.

## TTL (Time to Live)

**TTL** defines how long a credential is valid. Shorter is better.

- **Minimum**: 1 minute
- **Default**: Configured per backend (typically 1 hour)
- **Maximum**: Configured per backend (typically 24 hours)

### Choosing a TTL

| Task Type | Recommended TTL |
|-----------|-----------------|
| Quick API call | 5-15 minutes |
| CI/CD job | 1 hour |
| Long-running task | 2-4 hours |
| Background job | Match job timeout |

## Audit Log

Every credential issuance is logged in the **audit log**:

```json
{
  "timestamp": "2024-01-15T15:00:00Z",
  "action": "credential_issued",
  "backend": "github",
  "scopes": ["repo:read"],
  "ttl": "1h",
  "metadata": {
    "agent_id": "my-agent",
    "ip": "192.168.1.100"
  }
}
```

Query the audit log via the API or CLI:

```bash
creddy audit list --backend github --since 24h
```

## Signing Keys

Creddy uses **Ed25519** keys to sign credentials. Keys are:

- Generated automatically on first run
- Stored in the data directory
- Rotatable without downtime

### Key Rotation

```bash
# Generate new key (old key remains valid)
creddy keys rotate

# List all keys
creddy keys list

# Revoke old key (after grace period)
creddy keys revoke 
```

---
## contributing.mdx

# Contributing

Creddy is open source and we welcome contributions from the community.

## Getting Involved

The easiest way to get involved is to [open an issue](https://github.com/getcreddy/creddy/issues/new) on GitHub.

### Report a Bug

Found something broken? [Open a bug report](https://github.com/getcreddy/creddy/issues/new?labels=bug) with:

- What you expected to happen
- What actually happened
- Steps to reproduce
- Your environment (OS, Creddy version)

### Request a Feature

Have an idea for Creddy? [Open a feature request](https://github.com/getcreddy/creddy/issues/new?labels=enhancement) describing:

- The problem you're trying to solve
- Your proposed solution
- Any alternatives you've considered

### Ask a Question

Not sure about something? [Open a discussion](https://github.com/getcreddy/creddy/issues/new?labels=question) â€” we're happy to help.

## Contributing Code

Want to contribute code? Great!

1. **Fork the repo** â€” [github.com/getcreddy/creddy](https://github.com/getcreddy/creddy)
2. **Create a branch** â€” `git checkout -b my-feature`
3. **Make your changes** â€” follow existing code style
4. **Test your changes** â€” `go test ./...`
5. **Open a PR** â€” describe what you changed and why

### Development Setup

```bash
# Clone your fork
git clone https://github.com/YOUR_USERNAME/creddy.git
cd creddy

# Build
go build -o creddy ./cmd/creddy

# Run tests
go test ./...

# Run the server locally
./creddy server --data-dir ./test-data
```

### Code Style

- Follow existing patterns in the codebase
- Add tests for new functionality
- Keep commits focused and well-described
- Update documentation if needed

## Documentation

This documentation site is also open source at [getcreddy/creddy-docs](https://github.com/getcreddy/creddy-docs).

Found a typo or want to improve the docs? PRs welcome!

## License

By contributing to Creddy, you agree that your contributions will be licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0).

---

Thank you for helping make Creddy better! ðŸ™

---
## examples.mdx

# Examples

Real-world patterns for using Creddy with AI agents and automation.

## CI/CD Bot with Read-Only Access

A bot that monitors PRs and runs checks, but can't push code:

```bash
# Enrollment
creddy enroll http://creddy:8400 --name ci-checker \
  --can github:myorg/api:read \
  --can github:myorg/web:read \
  --can github:myorg/infra:read
```

```bash
# In CI script
export GITHUB_TOKEN=$(creddy get github --read-only)
gh pr list --repo myorg/api
gh pr checks --repo myorg/api 123
```

## Coding Agent with Scoped Write Access

An AI coding agent that can modify code in specific repos:

```bash
# Enrollment
creddy enroll http://creddy:8400 --name coding-agent \
  --can github:myorg/api \
  --can github:myorg/shared-lib
```

```bash
# Agent workflow
export GITHUB_TOKEN=$(creddy get github)

# Clone and work
git clone https://x-access-token:${GITHUB_TOKEN}@github.com/myorg/api.git
cd api
# ... make changes ...
git commit -m "feat: add new endpoint"
git push origin feature-branch

# Create PR
gh pr create --title "Add new endpoint" --body "Implemented by coding-agent"
```

## Time-Limited Token for One-Off Task

Request a short-lived token for a quick operation:

```bash
# 5 minute token
TOKEN=$(creddy get github --ttl 5m --repo myorg/config)

# Quick read
curl -H "Authorization: Bearer $TOKEN" \
  https://api.github.com/repos/myorg/config/contents/settings.json
```

## Agent Requesting Additional Access

An agent that starts with minimal access and requests more as needed:

```bash
# Initial enrollment (conservative)
creddy enroll http://creddy:8400 --name helper-bot \
  --can github:myorg/docs:read

# Later, bot needs to edit docs
creddy request --can github:myorg/docs

# Admin approves, now bot can write
creddy get github  # includes write access to docs
```

## Multiple Repos in One Token

Agent working across several repos:

```bash
# Enrollment with multiple repos
creddy enroll http://creddy:8400 --name monorepo-agent \
  --can github:myorg/frontend \
  --can github:myorg/backend \
  --can github:myorg/shared

# Single token covers all repos
export GITHUB_TOKEN=$(creddy get github)

# Work across repos
gh api repos/myorg/frontend/pulls
gh api repos/myorg/backend/pulls
gh api repos/myorg/shared/pulls
```

## Org-Wide Access for Admin Bot

A trusted bot with access to all org repos:

```bash
# Enrollment with wildcard
creddy enroll http://creddy:8400 --name admin-bot \
  --can github:myorg/*
```

```bash
# Can access any repo in the org
creddy get github --repo myorg/any-repo
creddy get github --repo myorg/another-repo

# Or get token for all
creddy get github
```

## Script: Auto-Refresh Token

For long-running agents, refresh token before expiry:

```bash
#!/bin/bash
# refresh-token.sh

TOKEN_FILE=/tmp/github-token
REFRESH_MINS=50  # Refresh 10 mins before 1hr expiry

while true; do
  creddy get github > "$TOKEN_FILE"
  export GITHUB_TOKEN=$(cat "$TOKEN_FILE")
  echo "Token refreshed at $(date)"
  sleep $((REFRESH_MINS * 60))
done
```

## GitHub Actions Integration

Use Creddy in GitHub Actions for cross-repo access:

```yaml
# .github/workflows/deploy.yml
jobs:
  deploy:
    runs-on: self-hosted  # Must reach Creddy server
    steps:
      - name: Get deploy token
        run: |
          # Agent pre-enrolled with deploy repos access
          export CREDDY_URL=${{ secrets.CREDDY_URL }}
          export CREDDY_TOKEN=${{ secrets.CREDDY_AGENT_TOKEN }}
          echo "GITHUB_TOKEN=$(creddy get github)" >> $GITHUB_ENV
      
      - name: Deploy to infra repo
        run: |
          gh workflow run deploy.yml --repo myorg/infra
```

## Separate Read/Write Tokens

When you need different permission levels in the same workflow:

```bash
# Read token for fetching
READ_TOKEN=$(creddy get github --read-only)

# Write token only when needed
WRITE_TOKEN=$(creddy get github)

# Fetch with read token
git clone https://x-access-token:${READ_TOKEN}@github.com/myorg/repo.git

# Push with write token (only if changes made)
if [ -n "$(git status --porcelain)" ]; then
  git remote set-url origin https://x-access-token:${WRITE_TOKEN}@github.com/myorg/repo.git
  git push
fi
```

## Docker Container Agent

Running an agent in Docker with Creddy:

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y curl git
COPY creddy /usr/local/bin/

# Agent token passed via environment
ENV CREDDY_URL=http://creddy:8400
# CREDDY_TOKEN set at runtime
```

```bash
docker run -e CREDDY_TOKEN=$AGENT_TOKEN myagent \
  sh -c 'export GITHUB_TOKEN=$(creddy get github) && git clone ...'
```

## Kubernetes CronJob

Periodic task with fresh credentials each run:

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: repo-sync
spec:
  schedule: "0 * * * *"  # Every hour
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: sync
            image: myagent:latest
            env:
            - name: CREDDY_URL
              value: "http://creddy.creddy.svc:8400"
            - name: CREDDY_TOKEN
              valueFrom:
                secretKeyRef:
                  name: agent-credentials
                  key: token
            command:
            - sh
            - -c
            - |
              export GITHUB_TOKEN=$(creddy get github --ttl 30m)
              # ... sync logic ...
```

## Audit Query: Who Accessed What

Review credential usage:

```bash
# All GitHub tokens issued today
creddy audit --action token_issued --limit 50

# Tokens issued to a specific agent
creddy audit --agent-id abc-123

# Export for analysis
creddy audit --limit 1000 | jq '.[] | {agent: .agent_name, backend: .backend, time: .timestamp}'
```

---
## getting-started.mdx

# Getting Started

Creddy is a single binary that operates in two modes: as a **server** that holds your master secrets and issues short-lived credentials, and as a **client** that agents use to request them.

Get it running and issue your first credential in 5 minutes.

## 1. Install the Server

You need one Creddy server that holds your master keys. Agents connect to it to get temporary credentials â€” they never see the actual secrets.

Run this on the machine where you want to run the Creddy server:

```bash
curl -fsSL https://get.creddy.dev/install.sh | sudo sh -s -- --to /usr/local/bin
```

## 2. Start the Daemon

```bash
sudo creddy install --listen 0.0.0.0:8400
```

Creddy is now running as a systemd service on port 8400.

```bash
systemctl status creddy  # Check it's running
```

## 3. Add a Backend

Install the GitHub plugin and configure it:

```bash
sudo creddy plugin install github
```

```bash
creddy backend add github \
  --app-id YOUR_APP_ID \
  --private-key /path/to/private-key.pem \
  --installation-id YOUR_INSTALLATION_ID
```

> **Need a GitHub App?** See [GitHub Integration](/docs/integrations/github) for setup instructions.

## 4. Enroll a Client

On the machine that needs credentials (can be the same machine or a different one):

```bash
# Install the client
curl -fsSL https://get.creddy.dev/install.sh | sh

# Enroll with the server
creddy enroll https://your-server:8400
```

Approve the enrollment on the server:

```bash
creddy admin approve 
```

## 5. Get Credentials

```bash
creddy get github --owner myorg --repo myrepo
```

That's it! You've issued your first ephemeral credential.

**Manual Installation**

If you prefer to download binaries directly:

```bash
# macOS (Apple Silicon)
curl -LO https://get.creddy.dev/cli/latest/creddy-darwin-arm64
chmod +x creddy-darwin-arm64
sudo mv creddy-darwin-arm64 /usr/local/bin/creddy

# macOS (Intel)
curl -LO https://get.creddy.dev/cli/latest/creddy-darwin-amd64
chmod +x creddy-darwin-amd64
sudo mv creddy-darwin-amd64 /usr/local/bin/creddy

# Linux (amd64)
curl -LO https://get.creddy.dev/cli/latest/creddy-linux-amd64
chmod +x creddy-linux-amd64
sudo mv creddy-linux-amd64 /usr/local/bin/creddy

# Linux (arm64)
curl -LO https://get.creddy.dev/cli/latest/creddy-linux-arm64
chmod +x creddy-linux-arm64
sudo mv creddy-linux-arm64 /usr/local/bin/creddy
```

Verify checksums are available at `https://get.creddy.dev/cli/latest/manifest.json`.

---
## index.mdx

# Creddy

**Ephemeral credentials for AI agents.**

Creddy provides short-lived, scoped credentials for AI agents and automated systems. Instead of sharing long-lived API keys or passwords, Creddy generates temporary credentials that automatically expireâ€”reducing risk and improving auditability.

## Why Creddy?

Traditional credential management wasn't designed for the age of AI agents. When you give an agent access to your systems, you typically have two bad options:

1. **Share your credentials** â€” The agent now has your full access, forever
2. **Create long-lived API keys** â€” Better, but still risky if compromised

Creddy offers a third way: **ephemeral, scoped credentials** that exist only as long as needed.

## Key Features

- ðŸ” **Ephemeral by default** â€” Credentials expire automatically (minutes to hours, not months)
- ðŸŽ¯ **Scoped access** â€” Grant only the permissions needed for the task
- ðŸ“Š **Auditable** â€” Track every credential issued and used
- ðŸ¤– **Built for agents** â€” Simple API designed for programmatic access
- ðŸ”‘ **Signed tokens** â€” Cryptographically signed JWTs for verification

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     1. Request credential      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     2. Short-lived token       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 3. Use token
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  External   â”‚
â”‚  Service    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

1. Agent requests a credential for a specific backend (e.g., "github", "aws")
2. Creddy issues a signed, time-limited token
3. Agent uses the token to authenticate with the external service
4. Token expires automatically â€” no cleanup needed

## Quick Start

```bash
# Download the latest release (macOS Apple Silicon)
curl -sL $(curl -s https://api.github.com/repos/getcreddy/creddy/releases/latest | grep "browser_download_url.*darwin-arm64.tar.gz" | cut -d '"' -f 4) | tar -xz
sudo mv creddy /usr/local/bin/

# Start the server
creddy server

# Request a credential (from your agent)
curl -X POST http://localhost:8080/api/v1/credentials \
  -H "Content-Type: application/json" \
  -d '{"backend": "github", "ttl": "1h"}'
```

See [Getting Started](/docs/getting-started) for other platforms.

Ready to get started? Head to [Getting Started](/docs/getting-started).

---
## integrations/anthropic.mdx

# Anthropic Integration

> **ðŸš§ Coming Soon** â€” This integration is not yet available. Check back soon or [join the waitlist](https://creddy.dev) to be notified when it launches.

Creddy's Anthropic integration creates truly ephemeral API keys. Unlike static keys, these are created on-demand and automatically deleted when they expire or when an agent is unenrolled.

## How It Works

Creddy uses Anthropic's Admin API to manage API keys programmatically:

1. Agent requests `creddy get anthropic`
2. Creddy creates a new API key via Admin API
3. Returns real `sk-ant-...` key to the agent
4. On TTL expiry or unenroll â†’ Creddy deletes the key from Anthropic

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    creddy get anthropic    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    sk-ant-xxx (1h TTL)     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â”‚ claude / API calls                       â”‚ Admin API
       â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Anthropic  â”‚                            â”‚  Anthropic  â”‚
â”‚     API     â”‚                            â”‚  Admin API  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The key difference from GitHub: **the agent gets a real API key** that works with any client (Claude Code, SDKs, curl), but Creddy automatically cleans it up.

## Requirements

- **Anthropic Admin API access** â€” Requires Scale or Enterprise plan
- **Admin API key** â€” Generated from your Anthropic console

## Installation

```bash
creddy plugin install anthropic
```

## Server Setup

### 1. Get Admin API Key

1. Log into [console.anthropic.com](https://console.anthropic.com)
2. Go to Settings â†’ Admin API
3. Generate an Admin API key
4. Save it securely â€” it won't be shown again

### 2. Configure Creddy

Add to your Creddy config (`~/.creddy/config.yaml`):

```yaml
integrations:
  anthropic:
    plugin: creddy-anthropic
    config:
      admin_key: "sk-admin-..."
```

Or via CLI:

```bash
creddy backend add anthropic \
  --admin-key "sk-admin-..."
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "anthropic",
    "name": "anthropic",
    "config": {
      "admin_key": "sk-admin-..."
    }
  }'
```

## Agent Enrollment

Agents request Anthropic access during enrollment:

```bash
creddy enroll --server http://creddy:8400 --name my-agent \
  --can anthropic
```

Currently, Anthropic scopes are simple â€” an agent either has access or doesn't. Future versions may support model-level scoping.

## Requesting Keys

Once enrolled and approved:

```bash
# Get an API key (default 10 min TTL)
creddy get anthropic

# Get a key with custom TTL
creddy get anthropic --ttl 1h

# Use it immediately
export ANTHROPIC_API_KEY=$(creddy get anthropic)
claude "Hello, world"
```

### Using with Claude Code

```bash
# Set the key
export ANTHROPIC_API_KEY=$(creddy get anthropic --ttl 1h)

# Claude Code uses it automatically
claude code "implement a fibonacci function"
```

### Using with Python SDK

```python

# Key from environment (set via creddy get)
client = anthropic.Anthropic()

message = client.messages.create(
    model="claude-3-sonnet-20240229",
    max_tokens=1024,
    messages=[{"role": "user", "content": "Hello!"}]
)
```

## Key Lifecycle

### TTL Expiry

Keys are automatically deleted when their TTL expires:

```bash
# Request a 30-minute key
creddy get anthropic --ttl 30m

# After 30 minutes, Creddy's reaper:
# 1. Calls Anthropic Admin API to delete the key
# 2. Removes it from the active credentials database
```

The agent cannot use the key after expiry â€” it's deleted from Anthropic, not just Creddy.

### Agent Unenroll

When an agent is unenrolled, all their active keys are revoked:

```bash
# Admin unenrolls an agent
creddy unenroll my-agent

# Creddy:
# 1. Finds all active credentials for my-agent
# 2. Deletes each Anthropic key via Admin API
# 3. Removes the agent
```

This provides immediate revocation â€” no waiting for TTL expiry.

## Audit Trail

All key creation is logged:

```bash
creddy audit --limit 10
```

Shows who requested keys, when, and which agent.

## Security Considerations

### Admin Key Security

The Admin API key stored in Creddy can create and delete any API key in your organization. Protect it:

- Run Creddy on a trusted server (Tailscale, VPN, localhost)
- Use `creddy install` with security hardening
- Rotate the admin key periodically

### Key Visibility

Unlike GitHub tokens (which are scoped), Anthropic API keys have full access to your API quota. Consider:

- Short TTLs for untrusted agents
- Monitoring API usage per key name (`creddy-`)
- Using separate Anthropic organizations for different trust levels

## Comparison with Static Keys

| Aspect | Static Key | Creddy Ephemeral |
|--------|-----------|------------------|
| Lifetime | Forever | Minutes to hours |
| Revocation | Manual | Automatic on TTL/unenroll |
| Audit | None | Full trail |
| Agent compromise | Permanent exposure | Limited window |
| Key rotation | Manual | Automatic |

## Troubleshooting

### "Admin API access required"

You need a Scale or Enterprise plan for Admin API access. Contact Anthropic sales.

### "Failed to create API key"

Check that your admin key is valid and has permission to create API keys.

### Key not working

Verify the key was created successfully:

```bash
# Check active credentials
creddy list
```

If the key shows as active but doesn't work, the Admin API endpoint may have changed. Check Anthropic's documentation.

## Version History

### v0.1.3 (Latest)
- Added: External ID tracking for revocation
- Fixed: TTL handling for keys > 24h

### v0.1.2
- Added: Scope-based permission levels
- Improved: Error messages for API failures

### v0.1.1
- Fixed: Key cleanup on agent unenrollment

### v0.1.0
- Initial release
- Basic API key generation and revocation

---
## integrations/building.mdx

# Building Custom Integrations

This guide walks through creating a custom Creddy integration from scratch.

## Overview

Creddy integrations are implemented as plugins â€” standalone binaries that communicate with Creddy core via gRPC. The [Plugin SDK](https://github.com/getcreddy/creddy-plugin-sdk) handles the communication layer â€” you just implement the credential logic.

## Prerequisites

- Go 1.21 or later
- Basic understanding of the service you're integrating

## Quick Start

### 1. Create the project

```bash
mkdir creddy-myservice
cd creddy-myservice
go mod init github.com/yourorg/creddy-myservice
```

### 2. Add the SDK dependency

```bash
go get github.com/getcreddy/creddy-plugin-sdk
```

### 3. Implement the plugin

Create `main.go`:

```go
package main

    sdk "github.com/getcreddy/creddy-plugin-sdk"
)

func main() {
    sdk.ServeWithStandalone(&MyServicePlugin{}, nil)
}
```

Create `plugin.go`:

```go
package main

    "context"
    "encoding/json"
    "fmt"
    "time"

    sdk "github.com/getcreddy/creddy-plugin-sdk"
)

type MyServicePlugin struct {
    config *Config
}

type Config struct {
    APIKey  string `json:"api_key"`
    BaseURL string `json:"base_url"`
}

// Info returns plugin metadata
func (p *MyServicePlugin) Info(ctx context.Context) (*sdk.PluginInfo, error) {
    return &sdk.PluginInfo{
        Name:             "myservice",
        Version:          "0.1.0",
        Description:      "MyService API tokens",
        MinCreddyVersion: "0.4.0",
    }, nil
}

// Scopes returns the scope patterns this plugin handles
func (p *MyServicePlugin) Scopes(ctx context.Context) ([]sdk.ScopeSpec, error) {
    return []sdk.ScopeSpec{
        {
            Pattern:     "myservice:*",
            Description: "Full access to MyService",
            Examples:    []string{"myservice:*", "myservice:read"},
        },
    }, nil
}

// Configure parses and validates the configuration
func (p *MyServicePlugin) Configure(ctx context.Context, configJSON string) error {
    var config Config
    if err := json.Unmarshal([]byte(configJSON), &config); err != nil {
        return fmt.Errorf("invalid config: %w", err)
    }
    
    if config.APIKey == "" {
        return fmt.Errorf("api_key is required")
    }
    
    p.config = &config
    return nil
}

// Validate tests connectivity with the configured credentials
func (p *MyServicePlugin) Validate(ctx context.Context) error {
    if p.config == nil {
        return fmt.Errorf("plugin not configured")
    }
    
    // TODO: Make a test API call to verify credentials
    // Example: _, err := p.client.GetCurrentUser(ctx)
    
    return nil
}

// GetCredential generates a new ephemeral credential
func (p *MyServicePlugin) GetCredential(ctx context.Context, req *sdk.CredentialRequest) (*sdk.Credential, error) {
    if p.config == nil {
        return nil, fmt.Errorf("plugin not configured")
    }
    
    // TODO: Call your service's API to generate a token
    // This is where the actual integration logic goes
    
    token := "generated-token-here"
    expiresAt := time.Now().Add(req.TTL)
    
    return &sdk.Credential{
        Value:      token,
        ExpiresAt:  expiresAt,
        ExternalID: "optional-id-for-revocation",
        Metadata: map[string]string{
            "scope": req.Scope,
        },
    }, nil
}

// RevokeCredential revokes a previously issued credential
func (p *MyServicePlugin) RevokeCredential(ctx context.Context, externalID string) error {
    // TODO: Call your service's API to revoke the token
    // Return nil if revocation isn't supported
    return nil
}

// MatchScope checks if this plugin handles the given scope
func (p *MyServicePlugin) MatchScope(ctx context.Context, scope string) (bool, error) {
    // Return true if scope starts with "myservice:"
    return len(scope) > 10 && scope[:10] == "myservice:", nil
}
```

### 4. Build and test

```bash
# Build
go build -o creddy-myservice .

# Test standalone
./creddy-myservice info
./creddy-myservice scopes

# Test with config
echo '{"api_key": "test-key"}' > test-config.json
./creddy-myservice validate --config test-config.json
./creddy-myservice get --config test-config.json --scope "myservice:test" --ttl 10m
```

### 5. Install locally

```bash
cp creddy-myservice ~/.creddy/plugins/
```

## Plugin Interface

The SDK defines this interface:

```go
type Plugin interface {
    // Metadata
    Info(ctx context.Context) (*PluginInfo, error)
    Scopes(ctx context.Context) ([]ScopeSpec, error)
    
    // Configuration
    Configure(ctx context.Context, config string) error
    Validate(ctx context.Context) error
    
    // Credentials
    GetCredential(ctx context.Context, req *CredentialRequest) (*Credential, error)
    RevokeCredential(ctx context.Context, externalID string) error
    MatchScope(ctx context.Context, scope string) (bool, error)
}
```

### PluginInfo

```go
type PluginInfo struct {
    Name             string  // Plugin identifier (e.g., "github")
    Version          string  // Semantic version (e.g., "1.2.3")
    Description      string  // Human-readable description
    MinCreddyVersion string  // Minimum Creddy version required
}
```

### ScopeSpec

```go
type ScopeSpec struct {
    Pattern     string   // Scope pattern (e.g., "myservice:*")
    Description string   // What this scope grants
    Examples    []string // Example scope values
}
```

### CredentialRequest

```go
type CredentialRequest struct {
    Agent      Agent             // Agent requesting the credential
    Scope      string            // Requested scope
    TTL        time.Duration     // Requested time-to-live
    Parameters map[string]string // Additional parameters
}

type Agent struct {
    ID     string   // Unique agent identifier
    Name   string   // Human-readable name
    Scopes []string // Agent's authorized scopes
}
```

### Credential

```go
type Credential struct {
    Value      string            // The credential value (token, key, etc.)
    ExpiresAt  time.Time         // When the credential expires
    ExternalID string            // Optional ID for revocation
    Metadata   map[string]string // Optional additional data
}
```

## Development Workflow

### Standalone Mode

The SDK provides a CLI for testing without Creddy:

```bash
./creddy-myservice info                    # Show plugin metadata
./creddy-myservice scopes                  # List supported scopes
./creddy-myservice validate --config X     # Validate configuration
./creddy-myservice get --config X --scope Y --ttl 10m
./creddy-myservice revoke --config X --external-id Z
```

### Local Development

Use `CREDDY_PLUGIN_DIR` to point Creddy at your development build:

```bash
# Terminal 1: Build and watch
go build -o ./bin/creddy-myservice . && \
  CREDDY_PLUGIN_DIR=./bin creddy server

# Terminal 2: Test
creddy get myservice --scope "myservice:test"
```

### Debug Logging

Enable verbose plugin communication:

```bash
CREDDY_PLUGIN_DEBUG=1 creddy get myservice --scope "myservice:test"
```

## Best Practices

### Error Handling

Return clear, actionable errors:

```go
// Bad
return nil, fmt.Errorf("failed")

// Good
return nil, fmt.Errorf("myservice API error: %s (status %d)", resp.Message, resp.StatusCode)
```

### Configuration Validation

Validate early in `Configure()`:

```go
func (p *MyPlugin) Configure(ctx context.Context, configJSON string) error {
    var config Config
    if err := json.Unmarshal([]byte(configJSON), &config); err != nil {
        return fmt.Errorf("invalid JSON: %w", err)
    }
    
    // Validate required fields
    if config.APIKey == "" {
        return fmt.Errorf("api_key is required")
    }
    
    // Validate format
    if !strings.HasPrefix(config.APIKey, "sk_") {
        return fmt.Errorf("api_key must start with 'sk_'")
    }
    
    p.config = &config
    return nil
}
```

### Scope Matching

Be precise with scope matching:

```go
func (p *MyPlugin) MatchScope(ctx context.Context, scope string) (bool, error) {
    // Only match scopes that start with your prefix
    if !strings.HasPrefix(scope, "myservice:") {
        return false, nil
    }
    
    // Validate the scope is well-formed
    parts := strings.Split(scope, ":")
    if len(parts)  24*time.Hour {
        ttl = 24 * time.Hour  // Service max
    }
    
    // ... generate credential with this TTL
}
```

## Testing

### Unit Tests

```go
func TestPlugin_Configure(t *testing.T) {
    p := &MyServicePlugin{}
    
    // Valid config
    err := p.Configure(context.Background(), `{"api_key": "sk_test"}`)
    if err != nil {
        t.Fatalf("expected no error, got: %v", err)
    }
    
    // Missing required field
    err = p.Configure(context.Background(), `{}`)
    if err == nil {
        t.Fatal("expected error for missing api_key")
    }
}
```

### Integration Tests

```go
func TestPlugin_GetCredential(t *testing.T) {
    if os.Getenv("MYSERVICE_API_KEY") == "" {
        t.Skip("MYSERVICE_API_KEY not set")
    }
    
    p := &MyServicePlugin{}
    config := fmt.Sprintf(`{"api_key": "%s"}`, os.Getenv("MYSERVICE_API_KEY"))
    
    if err := p.Configure(context.Background(), config); err != nil {
        t.Fatalf("configure failed: %v", err)
    }
    
    cred, err := p.GetCredential(context.Background(), &sdk.CredentialRequest{
        Scope: "myservice:test",
        TTL:   10 * time.Minute,
    })
    if err != nil {
        t.Fatalf("get credential failed: %v", err)
    }
    
    if cred.Value == "" {
        t.Fatal("expected non-empty credential value")
    }
}
```

## Distribution

### Building Releases

```bash
# Build for multiple platforms
GOOS=darwin GOARCH=arm64 go build -o dist/creddy-myservice-darwin-arm64 .
GOOS=darwin GOARCH=amd64 go build -o dist/creddy-myservice-darwin-amd64 .
GOOS=linux GOARCH=amd64 go build -o dist/creddy-myservice-linux-amd64 .
GOOS=linux GOARCH=arm64 go build -o dist/creddy-myservice-linux-arm64 .
```

### GitHub Releases

Create a release with binaries attached. Users can install directly:

```bash
creddy plugin install https://github.com/yourorg/creddy-myservice/releases/download/v0.1.0/creddy-myservice-linux-amd64.tar.gz
```

### Plugin Registry

For wider distribution, consider submitting to the community plugins list in [Third-Party Plugins](/docs/plugins/third-party).

## Examples

- [creddy-github](https://github.com/getcreddy/creddy-github) â€” GitHub App tokens
- [creddy-anthropic](https://github.com/getcreddy/creddy-anthropic) â€” Anthropic API keys
- [creddy-doppler](https://github.com/getcreddy/creddy-doppler) â€” Doppler service tokens

---

Questions? [Open an issue](https://github.com/getcreddy/creddy/issues) or check the [Plugin SDK](https://github.com/getcreddy/creddy-plugin-sdk) repository.

---
## integrations/dockerhub.mdx

# Docker Hub Integration

> **ðŸš§ Coming Soon** â€” This integration is not yet available. Check back soon or [join the waitlist](https://creddy.dev) to be notified when it launches.

Creddy's Docker Hub integration creates scoped Personal Access Tokens for your AI agents. Tokens can be limited to specific repositories with read or write access.

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    creddy get dockerhub    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     dckr_pat_xxx (TTL)     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â”‚ docker pull/push                         â”‚ Hub API
       â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Docker Hub  â”‚                            â”‚ Docker Hub  â”‚
â”‚  Registry   â”‚                            â”‚     API     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Requirements

- Docker Hub account
- Personal Access Token with "Read, Write, Delete" scope (for creating scoped tokens)

## Server Setup

### 1. Create Admin Token

1. Log into [hub.docker.com](https://hub.docker.com)
2. Go to Account Settings â†’ Security â†’ Access Tokens
3. Create a token with "Read, Write, Delete" permissions
4. Save the token securely

### 2. Configure Creddy

```bash
creddy backend add dockerhub \
  --username "myuser" \
  --password "dckr_pat_..."
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "dockerhub",
    "name": "dockerhub",
    "config": {
      "username": "myuser",
      "password": "dckr_pat_..."
    }
  }'
```

## Agent Enrollment

```bash
creddy enroll --server http://creddy:8400 --name my-agent \
  --can dockerhub:myorg/myimage
```

### Scopes

| Scope | Description |
|-------|-------------|
| `dockerhub:*` | Full access to all repositories |
| `dockerhub:/*` | Access to all repos in a namespace |
| `dockerhub:/` | Access to a specific repository |
| `dockerhub:/:read` | Pull-only access |
| `dockerhub:/:write` | Push and pull access (default) |

## Requesting Tokens

```bash
# Get a token
TOKEN=$(creddy get dockerhub)

# Use with Docker
echo $TOKEN | docker login -u myuser --password-stdin

# Repository-scoped token
TOKEN=$(creddy get dockerhub --scope "dockerhub:myorg/myimage")

# Read-only token (pull only)
TOKEN=$(creddy get dockerhub --scope "dockerhub:myorg/myimage:read")
```

### Using in CI/CD

```yaml
# GitHub Actions example
- name: Login to Docker Hub
  run: |
    TOKEN=$(creddy get dockerhub --scope "dockerhub:myorg/myimage")
    echo $TOKEN | docker login -u myuser --password-stdin

- name: Build and push
  run: |
    docker build -t myorg/myimage:latest .
    docker push myorg/myimage:latest
```

### Using with Docker Compose

```bash
# Set credentials
export DOCKER_USERNAME=myuser
export DOCKER_PASSWORD=$(creddy get dockerhub)

# Use in compose
docker compose pull
docker compose up
```

## Token Lifecycle

### TTL Expiry

Tokens are automatically deleted when their TTL expires:

```bash
# Request a 1-hour token
creddy get dockerhub --ttl 1h

# After 1 hour, Creddy deletes the token from Docker Hub
```

### Agent Unenroll

When an agent is unenrolled, all their Docker Hub tokens are immediately revoked.

## Read vs Write Access

| Scope Suffix | Docker Actions |
|--------------|----------------|
| `:read` | `docker pull` only |
| `:write` (or no suffix) | `docker pull`, `docker push` |

```bash
# CI agent that only needs to pull
creddy enroll --server ... --name ci-runner \
  --can dockerhub:myorg/baseimage:read

# Build agent that pushes images
creddy enroll --server ... --name builder \
  --can dockerhub:myorg/*:write
```

## Security Considerations

- Use `:read` scopes for agents that don't need to push
- Scope tokens to specific repositories when possible
- Use short TTLs for CI/CD jobs
- The admin token stored in Creddy can create any scoped token

## Troubleshooting

### "Login failed"

- Verify username and password are correct
- Check the admin token hasn't expired
- Ensure the token has sufficient permissions

### "Token creation failed"

- You may have hit Docker Hub's token limit
- Verify your account is in good standing

### Pull works but push fails

- Check your scope includes write access (no `:read` suffix)
- Verify the repository exists and you have push permissions

## Version History

### v0.1.0 (Latest)
- Initial release
- Repository-scoped access tokens
- Read/write permission control

---
## integrations/doppler.mdx

# Doppler Integration

> **ðŸš§ Coming Soon** â€” This integration is not yet available. Check back soon or [join the waitlist](https://creddy.dev) to be notified when it launches.

Creddy's Doppler integration creates scoped service tokens that give agents access to specific project secrets. Tokens are ephemeral â€” created on-demand and automatically revoked when they expire or when an agent is unenrolled.

## How It Works

Creddy uses Doppler's API to manage service tokens:

1. Agent requests `creddy get doppler --project myapp --config prd`
2. Creddy creates a scoped service token via Doppler API
3. Returns the token to the agent
4. On TTL expiry or unenroll â†’ Creddy revokes the token

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  creddy get doppler    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  dp.st.xxx (1h TTL)    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                      â”‚
       â”‚ doppler secrets                      â”‚ Doppler API
       â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Doppler   â”‚                        â”‚   Doppler   â”‚
â”‚   Secrets   â”‚                        â”‚     API     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Unlike static service tokens that live forever, Creddy tokens are automatically cleaned up.

## Requirements

- **Doppler account** â€” Any plan
- **Workplace token** â€” With permission to create service tokens
- **Projects configured** â€” The projects agents will access

## Server Setup

### 1. Get a Doppler Token

You need a token that can manage service tokens. Options:

**Option A: Personal Token (simpler)**
1. Go to [dashboard.doppler.com](https://dashboard.doppler.com)
2. Click your avatar â†’ Tokens
3. Generate a Personal Token
4. Save it securely

**Option B: Service Account (recommended for production)**
1. Settings â†’ Service Accounts
2. Create a service account for Creddy
3. Grant it "Service Token Manager" role on relevant projects
4. Generate a token for the service account

### 2. Configure Creddy

```bash
creddy backend add doppler \
  --token "dp.pt.xxxx"
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "doppler",
    "name": "doppler",
    "config": {
      "token": "dp.pt.xxxx"
    }
  }'
```

## Agent Enrollment

Agents request access to specific projects and configs during enrollment:

```bash
# Access to production config
creddy enroll --server http://creddy:8400 --name deploy-bot \
  --can doppler:myapp/prd

# Access to multiple configs
creddy enroll --server http://creddy:8400 --name dev-bot \
  --can doppler:myapp/dev \
  --can doppler:myapp/stg

# Read-only access
creddy enroll --server http://creddy:8400 --name readonly-bot \
  --can doppler:myapp/prd:read
```

### Scope Format

```
doppler:project/config[:permission]
```

| Scope | Access |
|-------|--------|
| `doppler:myapp/prd` | Read/write to myapp production |
| `doppler:myapp/prd:read` | Read-only to myapp production |
| `doppler:myapp/*` | All configs in myapp project |
| `doppler:*` | All projects (use sparingly) |

## Requesting Tokens

Once enrolled and approved:

```bash
# Get a token for a specific config
creddy get doppler --project myapp --config prd

# With custom TTL
creddy get doppler --project myapp --config prd --ttl 2h

# Read-only token
creddy get doppler --project myapp --config prd --read-only
```

### Using with Doppler CLI

```bash
# Set the token
export DOPPLER_TOKEN=$(creddy get doppler --project myapp --config prd)

# Fetch secrets
doppler secrets

# Run with secrets injected
doppler run -- ./my-app
```

### Using with Direct API

```bash
# Get token
TOKEN=$(creddy get doppler --project myapp --config prd)

# Fetch secrets via API
curl -s "https://api.doppler.com/v3/configs/config/secrets/download?format=json" \
  -H "Authorization: Bearer $TOKEN"
```

### Using in Scripts

```bash
#!/bin/bash
# deploy.sh - Deployment script with ephemeral secrets access

# Get a short-lived token for this deployment
export DOPPLER_TOKEN=$(creddy get doppler --project myapp --config prd --ttl 10m)

# Deploy with secrets
doppler run -- kubectl apply -f deployment.yaml

# Token auto-revokes after TTL even if script crashes
```

## Token Lifecycle

### TTL Expiry

Tokens are automatically revoked when their TTL expires:

```bash
# Request a 30-minute token
creddy get doppler --project myapp --config prd --ttl 30m

# After 30 minutes, Creddy's reaper:
# 1. Calls Doppler API to revoke the token
# 2. Removes it from the active credentials database
```

The token stops working immediately â€” it's revoked at Doppler, not just in Creddy.

### Agent Unenroll

When an agent is unenrolled, all their active tokens are revoked:

```bash
# Admin unenrolls an agent
creddy unenroll deploy-bot

# Creddy:
# 1. Finds all active Doppler tokens for deploy-bot
# 2. Revokes each token via Doppler API
# 3. Removes the agent
```

## Multi-Project Access

Agents can have access to multiple projects:

```bash
# Enrollment with multiple projects
creddy enroll --server http://creddy:8400 --name infra-bot \
  --can doppler:frontend/prd \
  --can doppler:backend/prd \
  --can doppler:shared-secrets/prd:read
```

Request tokens for each project separately:

```bash
FRONTEND_TOKEN=$(creddy get doppler --project frontend --config prd)
BACKEND_TOKEN=$(creddy get doppler --project backend --config prd)
```

## Example: CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Get Doppler token
        run: |
          export DOPPLER_TOKEN=$(creddy get doppler \
            --server ${{ secrets.CREDDY_URL }} \
            --project myapp \
            --config prd \
            --ttl 15m)
          echo "DOPPLER_TOKEN=$DOPPLER_TOKEN" >> $GITHUB_ENV
      
      - name: Deploy
        run: |
          doppler run -- ./deploy.sh
```

## Example: Kubernetes Sidecar

```yaml
# Pod with Creddy sidecar for secret refresh
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
    - name: app
      image: myapp:latest
      env:
        - name: DOPPLER_TOKEN
          valueFrom:
            secretKeyRef:
              name: doppler-token
              key: token
    
    - name: creddy-sidecar
      image: creddy:latest
      command:
        - /bin/sh
        - -c
        - |
          while true; do
            TOKEN=$(creddy get doppler --project myapp --config prd --ttl 1h)
            kubectl create secret generic doppler-token \
              --from-literal=token=$TOKEN \
              --dry-run=client -o yaml | kubectl apply -f -
            sleep 3000  # Refresh every 50 min
          done
```

## Audit Trail

All token operations are logged:

```bash
creddy audit --limit 10
```

Shows which agent requested tokens for which project/config, when, and the token's TTL.

## Security Considerations

### Token Hierarchy

Doppler has a token hierarchy:
- **Personal tokens** â€” tied to a user, broad access
- **Service account tokens** â€” scoped to roles, recommended for Creddy
- **Service tokens** â€” what Creddy creates, scoped to single config

Creddy creates service tokens (most limited), using your personal/SA token (more privileged).

### Principle of Least Privilege

- Grant agents only the configs they need
- Use `:read` suffix when write isn't required
- Prefer specific project/config over wildcards
- Use short TTLs for sensitive configs

### Audit Access

Doppler logs all secret access. Combined with Creddy's audit:
- **Creddy**: Who requested tokens, when
- **Doppler**: What secrets were accessed

## Comparison with Static Service Tokens

| Aspect | Static Token | Creddy Ephemeral |
|--------|-------------|------------------|
| Lifetime | Forever | Minutes to hours |
| Scope | Single config | Single config |
| Revocation | Manual | Automatic on TTL/unenroll |
| Audit | Doppler only | Creddy + Doppler |
| Agent compromise | Permanent exposure | Limited window |
| Token rotation | Manual | Automatic |

## Troubleshooting

### "Permission denied creating service token"

Your Creddy token doesn't have permission to create service tokens in that project. Check:
- Personal token: You need access to the project
- Service account: Needs "Service Token Manager" role

### "Project not found"

Verify the project name matches exactly (case-sensitive):

```bash
doppler projects
```

### "Config not found"

Verify the config exists:

```bash
doppler configs --project myapp
```

### Token not working

If token shows as active in Creddy but doesn't work:

```bash
# Check active credentials
creddy list

# Test the token directly
curl -s "https://api.doppler.com/v3/me" \
  -H "Authorization: Bearer $DOPPLER_TOKEN"
```

## Version History

### v0.1.2 (Latest)
- Added: Config wildcard support (`doppler:project/*`)
- Fixed: Token revocation on TTL expiry

### v0.1.1
- Added: Read-only scope modifier
- Improved: Validation error messages

### v0.1.0
- Initial release
- Basic service token generation

---
## integrations/github.mdx

# GitHub Integration

Creddy's GitHub integration provides scoped, ephemeral installation tokens for your AI agents. Instead of sharing personal access tokens, agents request short-lived tokens with access to only the repositories they need.

## How It Works

Creddy uses a [GitHub App](https://docs.github.com/en/apps) to generate installation tokens. When an agent requests a GitHub credential:

1. Agent authenticates with Creddy using its agent token
2. Creddy validates the agent's scopes (which repos it can access)
3. Creddy generates a GitHub App installation token scoped to those repos
4. Token is returned to the agent (expires in 1 hour max)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     creddy get github      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     ghs_xxxxx (1h TTL)     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â”‚ git clone / gh api                       â”‚ GitHub App
       â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   GitHub    â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  GitHub App â”‚
â”‚   (repos)   â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Key Concepts

Before setup, understand these key points:

- **One GitHub App** â€” Create a single GitHub App that Creddy uses to generate tokens
- **Install per org/user** â€” Install the app into each GitHub org or user account where agents need access
- **Max permissions on app** â€” The GitHub App needs the *maximum* permissions any agent might request. Creddy can only reduce permissions, never expand beyond what the app has.
- **No webhooks needed** â€” Creddy only generates tokens; it doesn't receive events from GitHub

## Server Setup

### 1. Create a GitHub App

1. Go to [github.com/settings/apps/new](https://github.com/settings/apps/new)

2. **Basic info:**
   - **Name**: `creddy-yourcompany` (must be globally unique)
   - **Homepage URL**: Your Creddy server URL (or any URL)

3. **Webhook:**
   - âŒ **Uncheck "Active"** â€” Creddy doesn't need webhooks

4. **Permissions** â€” Set the *maximum* any agent might need:
   
   | Permission | Level | Use Case |
   |------------|-------|----------|
   | Contents | Read & Write | Clone, push, read files |
   | Metadata | Read | Required for all operations |
   | Pull requests | Read & Write | Create/manage PRs |
   | Issues | Read & Write | Create/manage issues |
   | Actions | Read | Check workflow status |
   | Commit statuses | Read & Write | Set status checks |

   Start with Contents + Metadata. Add more as needed.

5. **Where can this app be installed?**
   - "Only on this account" for private use
   - "Any account" if agents need access across orgs

6. **Create the app** and note the **App ID** (shown at top of app settings)

7. **Generate a private key:**
   - Scroll to "Private keys" section
   - Click "Generate a private key"
   - Downloads a `.pem` file â€” keep this secure!

### 2. Install the App

1. From your app's settings page, click **"Install App"** in the sidebar
2. Choose the org or user account to install on
3. Select **"All repositories"** or specific repos
4. Click **Install**
5. Note the **Installation ID** from the URL:
   ```
   https://github.com/settings/installations/12345678
                                              ^^^^^^^^
                                              This is your installation ID
   ```

Repeat for each org where agents need access.

### 3. Configure Creddy

```bash
# Add the GitHub backend
creddy backend add github \
  --app-id 123456 \
  --installation-id 12345678 \
  --private-key /path/to/app.pem
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "github",
    "name": "github",
    "config": {
      "app_id": 123456,
      "installation_id": 12345678,
      "private_key_pem": "-----BEGIN RSA PRIVATE KEY-----\n..."
    }
  }'
```

## Agent Enrollment

Agents request access to specific repositories during enrollment:

```bash
# Agent requests enrollment with repo access
creddy enroll http://creddy-server:8400 --name my-agent \
  --can github:owner/repo1 \
  --can github:owner/repo2
```

### Scope Format

| Scope | Description |
|-------|-------------|
| `github:owner/repo` | Access to a specific repository (read/write) |
| `github:owner/repo:read` | Read-only access to a repository |
| `github:owner/repo:write` | Explicit read/write access |
| `github:owner/*` | Access to all repos under an owner |
| `github:*` | Access to all repos the app can see |

### Read-Only Scopes

Suffix `:read` to restrict an agent to read-only access:

```bash
creddy enroll http://creddy-server:8400 --name ci-bot \
  --can github:myorg/frontend:read \
  --can github:myorg/backend:read
```

This agent can only request read-only tokensâ€”even if it tries `--read-only=false`, Creddy will enforce the ceiling.

## Requesting Tokens

Once enrolled and approved, agents can request tokens:

```bash
# Get a token for all your repos
creddy get github

# Get a read-only token
creddy get github --read-only

# Narrow to specific repos (subset of what you're allowed)
creddy get github --repo owner/repo1

# Custom TTL (max 1 hour)
creddy get github --ttl 30m
```

### Using the Token

The returned token works with any GitHub API client:

```bash
# Set the token
export GITHUB_TOKEN=$(creddy get github)

# Use with git
git clone https://x-access-token:${GITHUB_TOKEN}@github.com/owner/repo.git

# Use with gh CLI
gh api repos/owner/repo

# Use with curl
curl -H "Authorization: Bearer $GITHUB_TOKEN" \
  https://api.github.com/repos/owner/repo
```

### Verifying Token Scopes

To confirm tokens are properly scoped to specific repos:

```bash
# Get a scoped token
export GH_TOKEN=$(creddy get github)

# âœ… Should work - access your scoped repo
gh api repos/owner/allowed-repo/issues

# âŒ Should fail (404) - access a different private repo
gh api repos/owner/other-repo/issues

# âœ… Should work - create an issue in allowed repo
gh issue create --repo owner/allowed-repo --title "Test" --body "Token scoping works!"

# âŒ Should fail - create issue in different repo
gh issue create --repo owner/other-repo --title "Test" --body "This should fail"
```

If the token is correctly scoped, you'll get a 404 "Not Found" when accessing repos outside your agent's permissions.

## Adding More Repos Later

Agents can request additional repository access after enrollment:

```bash
# Agent requests more access
creddy request --can github:owner/repo3

# On the server, admin sees the request
creddy pending
# ID          TYPE        NAME        SCOPES
# abc-123     amendment   my-agent    ["github:owner/repo3"]

# Admin approves
creddy approve abc-123
```

Scopes are mergedâ€”the agent now has access to repo1, repo2, and repo3.

## Multi-Organization Setup

GitHub App installation tokens are scoped to a single installation (typically one org or user account). If your agents need access to repos across multiple orgs:

1. Install the GitHub App on each org
2. Configure multiple backends in Creddy:
   ```bash
   creddy backend add github-myorg --app-id 123 --installation-id 111 --private-key app.pem
   creddy backend add github-partner --app-id 123 --installation-id 222 --private-key app.pem
   ```
3. Agents request from the appropriate backend:
   ```bash
   creddy get github-myorg
   creddy get github-partner
   ```

## Token Permissions

The token inherits the permissions configured on your GitHub App, reduced by any scope restrictions:

| App Permission | Agent Scope | Token Gets |
|----------------|-------------|------------|
| Contents: Write | `github:owner/repo` | Contents: Write |
| Contents: Write | `github:owner/repo:read` | Contents: Read |
| Contents: Read | `github:owner/repo` | Contents: Read |

You cannot grant more permissions than the app hasâ€”Creddy only reduces, never expands.

## Limitations

### Maximum TTL: 1 Hour

GitHub installation tokens have a **hard limit of 1 hour** imposed by GitHub's API. If you request a longer TTL, Creddy will return an error:

```bash
$ creddy get github --ttl 4h
Error: github tokens have a maximum TTL of 1 hour (requested: 4h0m0s)
```

For longer-running tasks, your agent should request a fresh token before the current one expires.

### Token Revocation

GitHub tokens **can be revoked early** via the [revoke endpoint](https://docs.github.com/en/rest/apps/installations#revoke-an-installation-access-token). When Creddy's reaper runs:

1. Creddy calls GitHub's `DELETE /installation/token` endpoint
2. The token is immediately invalidated
3. Any further API calls with that token return `401 Unauthorized`

This means your requested TTL (e.g., `--ttl 5m`) is enforcedâ€”the token stops working after 5 minutes, not GitHub's default 1 hour.

## Audit Trail

Every token issued is logged:

```bash
creddy audit --limit 10
```

Shows who requested what, when, and from whereâ€”useful for security reviews and compliance.

## Plugin Download

The GitHub plugin is available from the Creddy plugin registry:

| Platform | Download |
|----------|----------|
| Linux (x64) | [creddy-github-linux-amd64](https://plugins.creddy.dev/github/v0.0.2/creddy-github-linux-amd64) |
| Linux (ARM64) | [creddy-github-linux-arm64](https://plugins.creddy.dev/github/v0.0.2/creddy-github-linux-arm64) |
| macOS (Intel) | [creddy-github-darwin-amd64](https://plugins.creddy.dev/github/v0.0.2/creddy-github-darwin-amd64) |
| macOS (Apple Silicon) | [creddy-github-darwin-arm64](https://plugins.creddy.dev/github/v0.0.2/creddy-github-darwin-arm64) |
| Windows (x64) | [creddy-github-windows-amd64.exe](https://plugins.creddy.dev/github/v0.0.2/creddy-github-windows-amd64.exe) |

**Checksums:** [manifest.json](https://plugins.creddy.dev/github/v0.0.2/manifest.json)

**Latest version:** [plugins.creddy.dev/github/latest/](https://plugins.creddy.dev/github/latest/)

## Version History

### v0.0.2 (Current)
- Initial public release
- GitHub App installation token generation
- Repository-level scoping (`github:owner/repo`)
- Read/write permission modifiers (`:read`, `:write`)
- Owner wildcard support (`github:owner/*`)
- Token revocation support
- Integration tests for token lifecycle

---
## integrations/index.mdx

# Integrations

Creddy connects to external services to issue ephemeral, scoped credentials. Each integration is distributed as a plugin that can be installed and updated independently.

## Available Integrations

| Integration | Description | Version |
|-------------|-------------|---------|
| [GitHub](/docs/integrations/github) | GitHub App installation tokens | `v0.0.2` |
| [OpenAI](/docs/integrations/openai) | OpenAI API keys via Admin API | `v0.0.1` |
| [Anthropic](/docs/integrations/anthropic) | Anthropic API keys | Coming Soon |
| [Doppler](/docs/integrations/doppler) | Doppler service tokens | Coming Soon |
| [Docker Hub](/docs/integrations/dockerhub) | Docker Hub access tokens | Coming Soon |
| [Replicated](/docs/integrations/replicated) | Replicated Vendor Portal tokens | Coming Soon |
| AWS | AWS IAM temporary credentials | Coming Soon |

## Installing Integrations

List available integrations:

```bash
creddy plugin list
```

Install an integration:

```bash
# Install latest version
creddy plugin install github

# Install specific version
creddy plugin install github@0.0.2

# Install multiple
creddy plugin install github anthropic doppler
```

## Managing Integrations

Check for updates:

```bash
creddy plugin outdated
```

Upgrade:

```bash
# Upgrade specific integration
creddy plugin upgrade github

# Upgrade all
creddy plugin upgrade --all
```

View details:

```bash
creddy plugin info github
```

Remove:

```bash
creddy plugin remove github
```

## Using Integrations

Once installed, add the backend configuration:

```bash
# Example: GitHub
creddy backend add github \
  --app-id 123456 \
  --installation-id 78901234 \
  --private-key /path/to/app.pem
```

Then request credentials:

```bash
creddy get github --scope "github:myorg/myrepo"
```

Each integration has its own configuration and scopes â€” see the individual integration pages for details.

## Custom & Private Integrations

Install from a URL for private or custom integrations:

```bash
creddy plugin install https://internal.corp/creddy-salesforce.tar.gz
```

See [Building Custom Integrations](/docs/integrations/building) to create your own.

## Third-Party Integrations

Third-party integrations are created by the community. Before installing:

- âœ… Review the source code
- âœ… Check the publisher
- âœ… Verify checksums if provided

Third-party integrations run as subprocesses and receive the configuration you provide, but cannot access other backends or Creddy's database directly.

---
## integrations/openai.mdx

# OpenAI Integration

Creddy's OpenAI integration creates ephemeral API keys for your AI agents. Keys are created on-demand via the OpenAI Admin API and automatically deleted when they expire.

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     creddy get openai      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    sk-svcacct-xxx (TTL)    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â”‚ API calls                                â”‚ Admin API
       â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OpenAI    â”‚                            â”‚   OpenAI    â”‚
â”‚     API     â”‚                            â”‚  Admin API  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

When an agent requests credentials:
1. Creddy creates a new service account via the Admin API
2. OpenAI returns a fresh API key (`sk-svcacct-...`)
3. Creddy tracks the TTL and returns the key to the agent
4. On expiry, Creddy deletes the service account (key immediately revoked)

## Requirements

- OpenAI organization account
- **Admin API key** (`sk-admin-...`) â€” requires organization owner to create
- Project ID (defaults to first active project)

## Server Setup

### 1. Create an Admin API Key

Admin API keys are different from regular API keys. Only organization owners can create them.

1. Log into [platform.openai.com](https://platform.openai.com)
2. Go to **Settings â†’ Organization â†’ Admin API Keys**  
   Direct link: [platform.openai.com/settings/organization/admin-keys](https://platform.openai.com/settings/organization/admin-keys)
3. Click **Create admin key**
4. Give it a name (e.g., "creddy")
5. Copy the key â€” it starts with `sk-admin-`

> **Important:** Admin API keys can only be created by organization owners and have full administrative access. Keep them secure.

### 2. Configure Creddy

```bash
creddy backend add openai \
  --admin-key "sk-admin-..."
```

Optionally specify a project:

```bash
creddy backend add openai \
  --admin-key "sk-admin-..." \
  --project-id "proj_abc123"
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "openai",
    "name": "openai",
    "config": {
      "admin_key": "sk-admin-...",
      "project_id": "proj_abc123"
    }
  }'
```

If no `project_id` is specified, Creddy uses the first active project in your organization.

## Agent Enrollment

```bash
creddy enroll --server http://creddy:8400 --name my-agent \
  --can openai
```

### Scopes

| Scope | Description |
|-------|-------------|
| `openai` | Full API access |
| `openai:gpt` | Access to GPT models (chat completions) |
| `openai:dall-e` | Access to DALL-E image generation |
| `openai:whisper` | Access to Whisper audio transcription |

> **Note:** OpenAI API keys currently provide full API access regardless of scope. Scopes are informational and used for policy enforcement within Creddy.

## Requesting Keys

```bash
# Get an API key (1 hour default TTL)
export OPENAI_API_KEY=$(creddy get openai)

# Custom TTL
export OPENAI_API_KEY=$(creddy get openai --ttl 30m)

# Scoped request (for policy enforcement)
export OPENAI_API_KEY=$(creddy get openai --scope "openai:gpt")
```

### Using with Python

```python

from openai import OpenAI

# Uses OPENAI_API_KEY from environment
client = OpenAI()

response = client.chat.completions.create(
    model="gpt-4",
    messages=[{"role": "user", "content": "Hello!"}]
)
```

### Using with curl

```bash
curl https://api.openai.com/v1/chat/completions \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"model": "gpt-4", "messages": [{"role": "user", "content": "Hello!"}]}'
```

## Key Lifecycle

### Creation

When you request a key, Creddy:
1. Creates a service account via `POST /v1/organization/projects/{project_id}/service_accounts`
2. OpenAI returns the service account with an API key
3. Key is immediately usable (may take 1-2 seconds to propagate)

### TTL Expiry

When the TTL expires, Creddy:
1. Deletes the service account via `DELETE /v1/organization/projects/{project_id}/service_accounts/{id}`
2. Key is immediately invalidated (may take a few seconds to propagate)

### Agent Unenroll

When an agent is unenrolled, all their active OpenAI keys are revoked immediately.

## Security Considerations

- **Protect your Admin API key** â€” it can create/delete any service account in your organization
- Use short TTLs (30m-1h) for untrusted agents
- Consider separate OpenAI organizations for different trust levels
- Monitor usage in the [OpenAI dashboard](https://platform.openai.com/usage)
- Service accounts appear in Settings â†’ Organization â†’ Projects â†’ [Project] â†’ Service Accounts

## Troubleshooting

### "admin_key must be an Admin API key (starts with sk-admin-)"

You're using a regular API key. Admin API keys:
- Start with `sk-admin-`
- Are created at [Settings â†’ Organization â†’ Admin API Keys](https://platform.openai.com/settings/organization/admin-keys)
- Require organization owner access to create

### "no projects found in organization"

Your organization needs at least one project. Create one in the OpenAI dashboard under Settings â†’ Organization â†’ Projects.

### "Key not working immediately after creation"

OpenAI has eventual consistency. Keys may take 1-2 seconds to become active after creation. The Creddy plugin handles this automatically.

### "Key still works after revocation"

OpenAI's key revocation can take up to 10 seconds to propagate. This is expected behavior.

## API Endpoints Used

For reference, the plugin uses these OpenAI Admin API endpoints:

| Operation | Endpoint |
|-----------|----------|
| List projects | `GET /v1/organization/projects` |
| Create service account | `POST /v1/organization/projects/{project_id}/service_accounts` |
| Delete service account | `DELETE /v1/organization/projects/{project_id}/service_accounts/{id}` |

## Version History

### v0.0.1 (Latest)
- Initial release
- Admin API implementation using service accounts
- Admin key validation (`sk-admin-` prefix required)
- Automatic project discovery
- Integration tests

---
## integrations/replicated.mdx

# Replicated Integration

> **ðŸš§ Coming Soon** â€” This integration is not yet available. Check back soon or [join the waitlist](https://creddy.dev) to be notified when it launches.

Creddy's Replicated integration creates scoped Service Account tokens for the Vendor Portal API. Tokens can be limited to specific applications and channels.

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    creddy get replicated   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Agent     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚   Creddy    â”‚
â”‚             â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚   Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        token (TTL)         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â”‚ replicated CLI                           â”‚ Vendor API
       â–¼                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Replicated  â”‚                            â”‚ Replicated  â”‚
â”‚   Vendor    â”‚                            â”‚  Vendor API â”‚
â”‚   Portal    â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Requirements

- Replicated Vendor Portal account
- API token with permission to create Service Accounts
- Team admin or owner role

## Server Setup

### 1. Get Admin API Token

1. Log into [vendor.replicated.com](https://vendor.replicated.com)
2. Go to Team Settings â†’ API Tokens (or Service Accounts)
3. Create a token with admin permissions
4. Note your Application ID(s) if you want to scope by default

### 2. Configure Creddy

```bash
creddy backend add replicated \
  --api-token "..." \
  --app-id "app_abc123"   # optional default app
```

Or via API:

```bash
curl -X POST http://localhost:8400/v1/admin/backends \
  -H "Content-Type: application/json" \
  -d '{
    "type": "replicated",
    "name": "replicated",
    "config": {
      "api_token": "...",
      "app_id": "app_abc123"
    }
  }'
```

## Agent Enrollment

```bash
creddy enroll --server http://creddy:8400 --name release-bot \
  --can replicated:app_abc123
```

### Scopes

| Scope | Description |
|-------|-------------|
| `replicated:*` | Full Vendor Portal access |
| `replicated:` | Access scoped to a specific application |
| `replicated:/` | Access scoped to an app and channel |
| `replicated::read` | Read-only access to application |

## Requesting Tokens

```bash
# Get a token with full access
export REPLICATED_API_TOKEN=$(creddy get replicated)

# App-scoped token
export REPLICATED_API_TOKEN=$(creddy get replicated --scope "replicated:app_abc123")

# Channel-scoped token
export REPLICATED_API_TOKEN=$(creddy get replicated --scope "replicated:app_abc123/Stable")

# Read-only token
export REPLICATED_API_TOKEN=$(creddy get replicated --scope "replicated:app_abc123:read")
```

### Using with Replicated CLI

```bash
# Set the token
export REPLICATED_API_TOKEN=$(creddy get replicated)

# List releases
replicated release ls --app app_abc123

# Create a release
replicated release create --yaml-dir ./manifests --app app_abc123

# Promote to a channel
replicated release promote 123 Stable --app app_abc123
```

### Using in CI/CD

```yaml
# GitHub Actions example
- name: Get Replicated Token
  run: |
    export REPLICATED_API_TOKEN=$(creddy get replicated --scope "replicated:${{ env.APP_ID }}")
    echo "REPLICATED_API_TOKEN=$REPLICATED_API_TOKEN" >> $GITHUB_ENV

- name: Create Release
  run: |
    replicated release create \
      --yaml-dir ./manifests \
      --app ${{ env.APP_ID }} \
      --promote Unstable
```

## Token Lifecycle

### TTL Expiry

When the TTL expires, Creddy deletes the Service Account from Replicated:

```bash
# Request a 30-minute token
creddy get replicated --ttl 30m

# After 30 minutes, the Service Account is deleted
```

### Agent Unenroll

When an agent is unenrolled, all their Replicated Service Accounts are deleted immediately.

## RBAC Policies

The plugin creates Service Accounts with appropriate RBAC based on scope:

| Scope | RBAC Policy |
|-------|-------------|
| `replicated:*` | No explicit policy (team defaults) |
| `replicated:app_id` | App-level admin |
| `replicated:app_id:read` | App-level read |
| `replicated:app_id/channel` | App + Channel admin |
| `replicated:app_id/channel:read` | App + Channel read |

## Common Use Cases

### Release Automation

```bash
# Bot that creates releases to Unstable
creddy enroll --server ... --name release-bot \
  --can replicated:app_abc123/Unstable
```

### Multi-App Access

```bash
# Bot that needs access to multiple apps
creddy enroll --server ... --name multi-app-bot \
  --can replicated:app_abc123 \
  --can replicated:app_def456
```

### Read-Only Monitoring

```bash
# Bot that only reads release status
creddy enroll --server ... --name monitor-bot \
  --can replicated:app_abc123:read
```

## Security Considerations

- Use channel scopes for CI/CD that only promotes to specific channels
- Use `:read` scopes for monitoring and reporting agents
- The admin token can create Service Accounts with any permissions it has
- Service Accounts are visible in the Vendor Portal team settings

## Troubleshooting

### "Failed to create service account"

- Verify your admin token has permission to create Service Accounts
- Check you're a team admin or owner
- Ensure the app ID is correct

### "App not found"

- Verify the app ID exists and you have access
- App IDs are case-sensitive

### Token not working with CLI

- Ensure the token is exported correctly
- Check the RBAC policy grants sufficient permissions
- Try with `--app` flag explicitly

## Version History

### v0.1.0 (Latest)
- Initial release
- Service Account creation with RBAC policies
- App and channel scoping

---
## pricing.mdx

# Pricing

**Creddy is free and open source.**

## Forever Free

Creddy is licensed under [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0) â€” one of the most permissive open source licenses available. You can:

- âœ… Use Creddy for personal or commercial projects
- âœ… Modify the source code
- âœ… Distribute your modifications
- âœ… Use it in proprietary software
- âœ… Self-host without limits

## No Hidden Costs

There are no:

- âŒ Premium tiers
- âŒ Usage limits
- âŒ Per-agent fees
- âŒ Enterprise paywalls
- âŒ Cloud-only features

Everything is included. Every feature. Every integration.

## Why Free?

Credential management for AI agents is a fundamental security need. We believe every developer building with AI agents should have access to proper credential isolation without cost being a barrier.

Creddy is built and maintained by developers who believe in open source infrastructure for the AI ecosystem.

## Self-Hosted Only

Creddy runs on your infrastructure. There's no hosted version and no plans for one. This means:

- **Your secrets stay yours** â€” credentials never leave your network
- **No vendor lock-in** â€” switch or fork anytime
- **Full control** â€” customize to your needs

## Support

- ðŸ“– [Documentation](/docs) â€” comprehensive guides and reference
- ðŸ’¬ [GitHub Issues](https://github.com/getcreddy/creddy/issues) â€” bug reports and feature requests
- ðŸ¤ [Contributing](/docs/contributing) â€” help make Creddy better

---

Ready to get started? Check out the [Getting Started](/docs/getting-started) guide.

---
## reference/api.mdx

# API Reference

Creddy exposes a REST API for credential management.

## Base URL

```
http://localhost:8080/api/v1
```

## Authentication

All endpoints (except enrollment initiation and health) require request signing. See [Client Authentication](/docs/authentication) for details.

```
X-Creddy-Client: cli_xyz789
X-Creddy-Timestamp: 1708531200
X-Creddy-Signature: base64(...)
```

----|------|----------|-------------|
| `public_key` | string | Yes | Base64-encoded Ed25519 public key |
| `name` | string | Yes | Human-readable client name |
| `metadata` | object | No | Client metadata (hostname, user, OS) |

#### Example Request

```bash
curl -X POST http://localhost:8080/api/v1/enrollments \
  -H "Content-Type: application/json" \
  -d '{
    "public_key": "MCowBQYDK2VwAyEA...",
    "name": "my-laptop",
    "metadata": {
      "hostname": "marcbook.local",
      "username": "marc",
      "os": "darwin",
      "arch": "arm64"
    }
  }'
```

#### Response

```json
{
  "enrollment_id": "enr_abc123",
  "status": "pending",
  "expires_at": "2024-01-15T16:05:00Z",
  "poll_interval_ms": 2000
}
```

---

### Poll Enrollment Status

Check if an enrollment has been approved.

```
GET /api/v1/enrollments/{enrollment_id}/status
```

#### Response (Pending)

```json
{
  "status": "pending",
  "expires_at": "2024-01-15T16:05:00Z"
}
```

#### Response (Approved)

```json
{
  "status": "approved",
  "client_id": "cli_xyz789",
  "server_public_key": "MCowBQYDK2VwAyEA..."
}
```

#### Response (Denied)

```json
{
  "status": "denied",
  "reason": "Unknown device"
}
```

---

### List Pending Enrollments (Admin)

```
GET /api/v1/admin/enrollments?status=pending
```

#### Response

```json
{
  "enrollments": [
    {
      "enrollment_id": "enr_abc123",
      "name": "my-laptop",
      "public_key_fingerprint": "SHA256:xK3E8f...",
      "metadata": {
        "hostname": "marcbook.local",
        "username": "marc"
      },
      "requested_at": "2024-01-15T16:00:00Z",
      "expires_at": "2024-01-15T16:05:00Z",
      "ip_address": "192.168.1.50"
    }
  ]
}
```

---

### Approve Enrollment (Admin)

```
POST /api/v1/admin/enrollments/{enrollment_id}/approve
```

#### Request Body

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | string | No | Client role: `operator` (default) or `admin` |
| `note` | string | No | Admin note |

#### Response

```json
{
  "client_id": "cli_xyz789",
  "status": "approved"
}
```

---

### Deny Enrollment (Admin)

```
POST /api/v1/admin/enrollments/{enrollment_id}/deny
```

#### Request Body

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `reason` | string | No | Reason for denial |

---

## Credential Endpoints

### Issue Credential

Issue a new ephemeral credential.

```
POST /api/v1/credentials
```

#### Request Body

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `backend` | string | Yes | Backend identifier |
| `ttl` | string | No | Time to live (e.g., "1h", "30m") |
| `scopes` | string[] | No | Requested scopes |
| `metadata` | object | No | Custom metadata for audit |

#### Example Request

```bash
curl -X POST http://localhost:8080/api/v1/credentials \
  -H "Content-Type: application/json" \
  -H "X-Creddy-Client: cli_xyz789" \
  -H "X-Creddy-Timestamp: 1708531200" \
  -H "X-Creddy-Signature: ..." \
  -d '{
    "backend": "github",
    "ttl": "1h",
    "scopes": ["repo:read", "issues:write"]
  }'
```

#### Response

```json
{
  "id": "cred_abc123",
  "token": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
  "backend": "github",
  "scopes": ["repo:read", "issues:write"],
  "expires_at": "2024-01-15T16:00:00Z",
  "created_at": "2024-01-15T15:00:00Z"
}
```

---

### Get Credential

Retrieve credential metadata (not the token itself).

```
GET /api/v1/credentials/{id}
```

#### Response

```json
{
  "id": "cred_abc123",
  "backend": "github",
  "scopes": ["repo:read"],
  "expires_at": "2024-01-15T16:00:00Z",
  "created_at": "2024-01-15T15:00:00Z",
  "revoked": false
}
```

---

### Revoke Credential

Revoke a credential before expiration.

```
DELETE /api/v1/credentials/{id}
```

#### Response

```json
{
  "id": "cred_abc123",
  "revoked": true,
  "revoked_at": "2024-01-15T15:30:00Z"
}
```

---

## Client Management (Admin)

### List Clients

```
GET /api/v1/admin/clients
```

#### Response

```json
{
  "clients": [
    {
      "client_id": "cli_xyz789",
      "name": "my-laptop",
      "role": "operator",
      "public_key_fingerprint": "SHA256:xK3E8f...",
      "created_at": "2024-01-15T15:00:00Z",
      "last_seen": "2024-01-15T16:30:00Z",
      "status": "active"
    }
  ]
}
```

---

### Revoke Client

```
DELETE /api/v1/admin/clients/{client_id}
```

#### Response

```json
{
  "client_id": "cli_xyz789",
  "status": "revoked",
  "revoked_at": "2024-01-15T16:00:00Z"
}
```

---

## Backend Endpoints

### List Backends

```
GET /api/v1/backends
```

#### Response

```json
{
  "backends": [
    {
      "id": "github",
      "type": "github",
      "default_ttl": "1h",
      "max_ttl": "24h",
      "allowed_scopes": ["repo:*", "issues:*"]
    }
  ]
}
```

---

### Get Backend

```
GET /api/v1/backends/{id}
```

---

## Other Endpoints

### Health Check

```
GET /health
```

No authentication required.

#### Response

```json
{
  "status": "healthy",
  "version": "0.1.0"
}
```

---

### Audit Log

```
GET /api/v1/audit
```

#### Query Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `backend` | string | Filter by backend |
| `client_id` | string | Filter by client |
| `since` | string | Start time (ISO 8601 or duration) |
| `until` | string | End time |
| `limit` | int | Max results (default 100) |

---

## Error Responses

All errors follow this format:

```json
{
  "error": {
    "code": "invalid_request",
    "message": "Backend 'unknown' not found"
  }
}
```

### Error Codes

| Code | HTTP Status | Description |
|------|-------------|-------------|
| `invalid_request` | 400 | Invalid request body or parameters |
| `unauthorized` | 401 | Missing or invalid authentication |
| `forbidden` | 403 | Insufficient permissions |
| `not_found` | 404 | Resource not found |
| `enrollment_expired` | 410 | Enrollment request has expired |
| `enrollment_denied` | 403 | Enrollment was denied |
| `client_revoked` | 403 | Client has been revoked |
| `internal_error` | 500 | Server error |

---
## reference/cli.mdx

# CLI Reference

Creddy command-line interface.

## Global Flags

| Flag | Description |
|------|-------------|
| `--config` | Path to config file |
| `--server` | Server URL |
| `-v, --verbose` | Verbose output |

---|---------|-------------|
| `--name` | hostname | Client name |
| `--server` | | Server URL (required) |
| `--admin-token` | | Bootstrap admin token (first admin only) |
| `--timeout` | `5m` | Enrollment timeout |

#### Examples

```bash
# Standard enrollment (requires admin approval)
creddy init --name my-laptop --server https://creddy.example.com

# Bootstrap first admin with token
creddy init --name admin-laptop --server https://creddy.example.com \
  --admin-token ctk_XXXXX
```

---

### `creddy get`

Request a credential from a backend.

```bash
creddy get  [flags]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--ttl` | Backend default | Time to live |
| `--scope` | | Scopes (repeatable) |
| `-o, --output` | `text` | Output format (text, json, env) |

#### Examples

```bash
# Basic usage
creddy get github

# With TTL and scopes
creddy get github --ttl 30m --scope repo:read --scope issues:write

# Output as environment variables
creddy get aws --output env
export $(creddy get aws -o env)
```

---

### `creddy backends`

List available backends.

```bash
creddy backends [flags]
```

| Flag | Description |
|------|-------------|
| `-o, --output` | Output format (text, json) |

---

### `creddy rotate-key`

Rotate the client's keypair.

```bash
creddy rotate-key [flags]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--grace-period` | `24h` | How long to accept old key |

---

### `creddy status`

Show client status and server connection.

```bash
creddy status
```

#### Example Output

```
Client: my-laptop (cli_xyz789)
Server: https://creddy.example.com
Status: connected
Role:   operator

Fingerprint: SHA256:xK3E8f...
Last sync:   2024-01-15 16:30:00
```

---

## Admin Commands

### `creddy admin enrollments`

List pending enrollment requests.

```bash
creddy admin enrollments [flags]
```

| Flag | Description |
|------|-------------|
| `--status` | Filter by status (pending, approved, denied) |
| `-o, --output` | Output format (text, json) |

#### Example Output

```
ID            NAME        USER    HOST              IP              EXPIRES
enr_abc123    my-laptop   marc    marcbook.local    192.168.1.50    4:32
enr_def456    ci-runner   root    ci-node-01        10.0.0.50       2:15
```

---

### `creddy admin approve`

Approve an enrollment request.

```bash
creddy admin approve  [flags]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--role` | `operator` | Client role (operator, admin) |
| `--note` | | Admin note |

#### Example

```bash
creddy admin approve enr_abc123 --role admin --note "Marc's laptop"
```

---

### `creddy admin deny`

Deny an enrollment request.

```bash
creddy admin deny  [flags]
```

| Flag | Description |
|------|-------------|
| `--reason` | Reason for denial |

---

### `creddy admin clients`

List registered clients.

```bash
creddy admin clients [flags]
```

| Flag | Description |
|------|-------------|
| `--status` | Filter by status (active, revoked) |
| `-o, --output` | Output format (text, json) |

#### Example Output

```
ID            NAME        ROLE      LAST SEEN           STATUS
cli_xyz789    my-laptop   admin     2024-01-15 16:30    active
cli_abc123    ci-runner   operator  2024-01-15 14:00    active
```

---

### `creddy admin revoke`

Revoke a client's access.

```bash
creddy admin revoke  [flags]
```

| Flag | Description |
|------|-------------|
| `--reason` | Reason for revocation |

---

## Server Commands

### `creddy server`

Start the Creddy server.

```bash
creddy server [flags]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--port` | `8080` | Server port |
| `--host` | `0.0.0.0` | Host to bind |
| `--data-dir` | `~/.creddy` | Data directory |

---

### `creddy backend add`

Add a backend to the server.

```bash
creddy backend add  --type  [flags]
```

| Flag | Description |
|------|-------------|
| `--type` | Backend type (github, aws, generic) |
| `--config` | Path to config file |

#### Example

```bash
creddy backend add github --type github \
  --app-id 12345 \
  --private-key ./github-app.pem
```

---

### `creddy keys`

Manage server signing keys.

```bash
creddy keys 
```

#### Subcommands

- `creddy keys list` â€” List all signing keys
- `creddy keys rotate` â€” Generate a new signing key
- `creddy keys revoke ` â€” Revoke a signing key
- `creddy keys export ` â€” Export public key

---

### `creddy audit`

Query the audit log.

```bash
creddy audit [flags]
```

| Flag | Default | Description |
|------|---------|-------------|
| `--backend` | | Filter by backend |
| `--client` | | Filter by client |
| `--since` | `24h` | Start time |
| `--until` | | End time |
| `--limit` | `100` | Max results |
| `-o, --output` | `text` | Output format |

---

## Environment Variables

| Variable | Description |
|----------|-------------|
| `CREDDY_SERVER` | Server URL |
| `CREDDY_CONFIG` | Config file path |
| `CREDDY_DATA_DIR` | Data directory |

---

## Exit Codes

| Code | Description |
|------|-------------|
| `0` | Success |
| `1` | General error |
| `2` | Invalid arguments |
| `3` | Connection error |
| `4` | Authentication error |
| `5` | Enrollment denied/expired |

---
## server.mdx

# Server Setup

This guide covers installing and configuring the Creddy server.

## Installation

### System Install (Recommended)

Install the binary to `/usr/local/bin`:

```bash
curl -fsSL https://get.creddy.dev/install.sh | sudo sh -s -- --to /usr/local/bin
```

### Install as a Daemon

Set up Creddy as a systemd service:

```bash
sudo creddy install --listen 0.0.0.0:8400
```

This automatically:
- Copies the binary to `/usr/local/bin/creddy` (if needed)
- Creates `/var/lib/creddy` for data storage
- Creates `/usr/local/lib/creddy/plugins` for system plugins
- Writes a hardened systemd unit file
- Enables and starts the service

**Options:**

| Flag | Default | Description |
|------|---------|-------------|
| `--listen` | `0.0.0.0:8400` | Address and port to listen on |
| `--data-dir` | `/var/lib/creddy` | Data directory |
| `--agent-inactivity-days` | `0` | Auto-unenroll inactive agents (0 = disabled) |

### Managing the Service

```bash
systemctl status creddy       # Check status
journalctl -u creddy -f       # View logs
sudo systemctl restart creddy # Restart
sudo creddy uninstall         # Remove service
```

## Configuration

### Data Directory

The server stores data in `/var/lib/creddy` (or `--data-dir`):

```
/var/lib/creddy/
â”œâ”€â”€ creddy.db        # SQLite database
â””â”€â”€ keys/
    â””â”€â”€ signing.key  # Ed25519 signing key
```

### Plugin Directory

System plugins are stored in `/usr/local/lib/creddy/plugins`.

User plugins (from `creddy plugin install`) go to `~/.local/share/creddy/plugins`.

The server searches both directories, so you can install plugins either way.

---

## Running Without systemd

### Foreground (Development)

```bash
creddy server --listen 127.0.0.1:8400
```

### Manual Systemd Setup

If you prefer to create the unit file yourself:

```ini
[Unit]
Description=Creddy credential server
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/creddy server --listen 0.0.0.0:8400 --db /var/lib/creddy/creddy.db
Restart=on-failure
RestartSec=5
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=/var/lib/creddy

[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl daemon-reload
sudo systemctl enable creddy
sudo systemctl start creddy
```

---

## Health Check

```bash
curl http://localhost:8400/health
```

Returns:
```json
{
  "status": "healthy",
  "version": "v0.0.9"
}
```

---

## Security Considerations

1. **Run behind a reverse proxy** â€” Use nginx/caddy for TLS termination
2. **Restrict network access** â€” Firewall the port, only allow trusted agents
3. **Enable agent inactivity cleanup** â€” `--agent-inactivity-days 30` removes stale enrollments
4. **Keep plugins updated** â€” `creddy plugin outdated` checks for updates

---

## Next Steps

- [Client Authentication](/docs/authentication) â€” How agents enroll and authenticate
- [GitHub Integration](/docs/integrations/github) â€” Configure GitHub App credentials
- [Building Integrations](/docs/integrations/building) â€” Create custom plugins
